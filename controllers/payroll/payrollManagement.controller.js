import prisma from "../../config/prismaClient.js";
import { asyncHandler } from "../../utils/asyncHandler.js";
import { ApiResponse } from "../../utils/ApiResponse.js";
import { hasPermission } from "../../middlewares/auth.middleware.js";
import { ApiError } from "../../utils/ApiError.js";
import { sendBulkEmail } from "../../utils/email.js";
import {
  validateMonthYear,
  validateSalaryInputs,
} from "../../utils/validation.utils.js";
import { calculateSalaryComponents } from "../../utils/salary.utils.js";

const generateSalary = asyncHandler(async (req, res) => {
  const { month, year, employeeType, departmentIds, employeeIds } = req.body
  const { companyId, role, departmentId, name } = req.user
  const { userType } = req

  if (!hasPermission(role, userType, "payroll:generate")) {
    throw new ApiError(403, "Insufficient permissions to generate payroll")
  }

  validateMonthYear(month, year)
  if (!companyId) throw new ApiError(401, "Company ID is required")

  const filter = { companyId, isActive: true }
  if (employeeType) filter.type = employeeType
  if (departmentIds?.length) filter.departmentId = { in: departmentIds.map(Number) }
  if (employeeIds?.length) filter.id = { in: employeeIds.map(Number) }
  if (role === "MANAGER" && userType === "employee") filter.departmentId = departmentId

  const existing = await prisma.payMaster.count({
    where: {
      companyId,
      month,
      year,
      ...(employeeType && { employee: { type: employeeType } }),
      ...(departmentIds?.length && {
        employee: { departmentId: { in: departmentIds.map(Number) } },
      }),
      ...(employeeIds?.length && {
        employeeId: { in: employeeIds.map(Number) },
      }),
    },
  })

  if (existing) {
    throw new ApiError(400, `Salaries for ${month}/${year} already generated. Use update instead.`)
  }

  const employees = await prisma.employee.findMany({
    where: filter,
    include: { department: true, designation: true },
  })

  if (!employees.length) throw new ApiError(404, "No eligible employees found")

  const { salaryRecords, errors } = await prisma.$transaction(async (tx) => {
    const records = [],
      errs = []

    for (const emp of employees) {
      try {
        if (!emp.salary || emp.salary <= 0) throw new Error("Invalid basic salary")

        // Simplified: Get most recent pay parameter for employee type
        const payParam = await tx.payParameter.findFirst({
          where: { companyId, employeeType: emp.type },
          orderBy: { effectiveDate: "desc" },
        })

        if (!payParam) throw new Error("Missing pay parameters")

        const components = calculateSalaryComponents(emp.salary, payParam, emp.type)

        const record = await tx.payMaster.create({
          data: {
            employeeId: emp.id,
            companyId,
            month,
            year,
            ...components,
            otherAll: 0,
            otherDeductions: 0,
            remarks: `Generated by ${name} on ${new Date().toISOString()}`,
          },
          include: {
            employee: {
              select: {
                employeeCode: true,
                name: true,
                type: true,
                department: true,
                designation: true,
                email: true,
              },
            },
          },
        })

        records.push(record)
      } catch (err) {
        errs.push(`Employee ${emp.employeeCode}: ${err.message}`)
      }
    }

    return { salaryRecords: records, errors: errs }
  })

  // Send emails (unchanged)
  for (const rec of salaryRecords) {
    if (!rec.employee.email) continue
    await sendBulkEmail([{ email: rec.employee.email, name: rec.employee.name }], "payslip", rec)
  }

  if (!salaryRecords.length) throw new ApiError(400, "No salaries generated. Check configuration.")

  const summary = salaryRecords.reduce((acc, s) => {
    acc[s.employee.type] = acc[s.employee.type] || { count: 0, total: 0 }
    acc[s.employee.type].count++
    acc[s.employee.type].total += Number(s.netSalary)
    return acc
  }, {})

  res.status(201).json(
    new ApiResponse(
      201,
      {
        count: salaryRecords.length,
        summary,
        salaries: salaryRecords,
        ...(errors.length && { errors }),
      },
      `Generated ${salaryRecords.length} salaries for ${month}/${year}`,
    ),
  )
})

const getEmployeeSalaries = asyncHandler(async (req, res) => {
  const {
    month,
    year,
    employeeId,
    employeeType,
    departmentId,
    designationId,
    page = 1,
    limit = 10,
    sortOrder = "asc",
  } = req.query;
  const { companyId, role, departmentId: mgrDeptId, id } = req.user;
  const { userType } = req;

  if (!companyId) throw new ApiError(401, "Company ID is required");

  const where = { companyId };
  if (month && year)
    Object.assign(where, { month: Number(month), year: Number(year) });

  if (role === "EMPLOYEE" && userType === "employee") where.employeeId = id;
  else if (role === "MANAGER" && userType === "employee") {
    const deptEmps = await prisma.employee.findMany({
      where: { departmentId: mgrDeptId, companyId },
      select: { id: true },
    });
    where.employeeId = { in: deptEmps.map((e) => e.id) };
  } else if (employeeId) where.employeeId = Number(employeeId);

  const skip = (page - 1) * limit;
  const [salaries, total] = await Promise.all([
    prisma.payMaster.findMany({
      where,
      skip,
      take: Number(limit),
      orderBy: [
        { year: "desc" },
        { month: "desc" },
        { employee: { name: sortOrder } },
      ],
      include: { employee: true },
    }),
    prisma.payMaster.count({ where }),
  ]);

  const filtered = salaries.filter((s) => {
    if (employeeType && s.employee.type !== employeeType) return false;
    if (departmentId && s.employee.departmentId !== Number(departmentId))
      return false;
    if (designationId && s.employee.designationId !== Number(designationId))
      return false;
    return true;
  });

  const summary = filtered.reduce((acc, s) => {
    acc[s.employee.type] = acc[s.employee.type] || {
      count: 0,
      totalGross: 0,
      totalNet: 0,
    };
    acc[s.employee.type].count++;
    acc[s.employee.type].totalGross += Number(s.grossSalary);
    acc[s.employee.type].totalNet += Number(s.netSalary);
    return acc;
  }, {});

  res.json(
    new ApiResponse(
      200,
      {
        salaries: filtered,
        pagination: {
          currentPage: Number(page),
          totalPages: Math.ceil(total / limit),
          totalCount: total,
          hasNext: skip + limit < total,
          hasPrev: page > 1,
        },
        summary,
      },
      "Salaries fetched successfully"
    )
  );
});

const updateSalary = asyncHandler(async (req, res) => {
  const { payMasterId } = req.params
  const { otherAll, otherDeductions, remarks, basicSalary } = req.body
  const { companyId, role, departmentId, userType } = req.user

  if (!hasPermission(role, userType, "payroll:update")) throw new ApiError(403, "Insufficient permissions")

  const record = await prisma.payMaster.findFirst({
    where: { id: Number(payMasterId), companyId },
    include: { employee: true },
  })

  if (!record) throw new ApiError(404, "Salary record not found")

  if (role === "MANAGER" && userType === "employee" && record.employee.departmentId !== departmentId)
    throw new ApiError(403, "Can only update your department's payroll")

  validateSalaryInputs(basicSalary, otherAll, otherDeductions)

  let updated = {}
  if (basicSalary !== undefined) {
    // Get most recent pay parameter for employee type
    const payParam = await prisma.payParameter.findFirst({
      where: { companyId, employeeType: record.employee.type },
      orderBy: { effectiveDate: "desc" },
    })

    if (payParam) updated = calculateSalaryComponents(basicSalary, payParam, record.employee.type)
  }

  const gross =
    (updated.basicSalary ?? record.basicSalary) +
    (updated.da ?? record.da) +
    (updated.ta ?? record.ta) +
    (updated.hra ?? record.hra) +
    (updated.spall ?? record.spall) +
    (updated.medicalAll ?? record.medicalAll) +
    (otherAll ?? record.otherAll)

  const deductions =
    (updated.epf ?? record.epf) +
    (updated.esi ?? record.esi) +
    (updated.tds ?? record.tds) +
    (updated.professionalTax ?? record.professionalTax) +
    (otherDeductions ?? record.otherDeductions)

  const net = gross - deductions

  const updatedRecord = await prisma.payMaster.update({
    where: { id: Number(payMasterId) },
    data: {
      ...updated,
      otherAll: otherAll ?? record.otherAll,
      otherDeductions: otherDeductions ?? record.otherDeductions,
      grossSalary: gross,
      totalDeductions: deductions,
      netSalary: net,
      remarks: remarks ?? record.remarks,
      updatedAt: new Date(),
    },
  })

  res.json(new ApiResponse(200, updatedRecord, "Salary updated successfully"))
})
export { generateSalary, getEmployeeSalaries, updateSalary };
